N cars numbered 1, 2, ... N are on an infinite road.  Car 1 is in
front, car 2 next (in front of car 3), etc.  The cars start to drive
down the road.  A car is allowed to pass the car in front of it.  When
it does, we increment the "pass count" for the car that moved ahead.

You're given a sequence of desired pass counts c_1, c_2 ... c_N.  Is
it possible for car 1 to pass c_1 times, car 2 to pass c_2 times, etc?
Give an algorithm that can determine this in O(N) time.

For example, if there are three cars, and (c_1, c_2, c_3) = (0,1,4)
then it is impossible.  On the other hand if (c_1, c_2, c_3) = (1,1,3)
then it can be done.  Here's how:  Car 3 passes 2 and 1. Now car 1
passes car 3.  Now car 2 passes car 3.  Now car 3 passes car 2.
Voila.
 
Solution:

   Order the cars from "bottom" to "top" where bottom is the last car
   in the list.

   We interpret the problem statement as follows.  We're looking for a
   sequence of swaps of neighboring cars where each car passes a
   designated number of times.  We can keep track of the "remaining
   pass count" for each car.  We're allowed to swap two neighboring
   cars if the bottom one has a remaining pass count>0.  When we do
   the swap, we decrement the swap count of the car that moved up.
   We're looking for a sequence of swaps that causes all the remaining
   pass counts to reach zero.

   Here's the algorithm.  First do the greedy bottom-to-top sweep.
   We swap each pair we come to as often as we need to make the bottom
   of the pair reach zero.  The sweep zeros out everything except
   (possibly) the top one.  Keep track of which one this was from
   the original ordering.  Call that one k.

   Now, run a different algorithm starting from the original counts,
   that determines if it is possible to zero position k at all.  In
   other words apply the most powerful zeroing algorithm to position
   k.  Here's how this works.  You push k to the bottom (pushing zeros
   out of the way before it).  Now push k all the way to the top.  If
   it gets to zero somewhere along the way, then the problem is
   solvable, otherwise it is not solvable.  (Pushing a zero down
   decrements the one below it.)

   Both passes are linear time.

   The reason the algorithm works is this.  First you have to convince
   yourself of the reasoning of the second pass.  That is, it is the 
   optimal way to zero out a pass-count on a given car.  And if it
   does
   not zero that count, then that count cannot be zeroed.

   The purpose of the first pass is to find the bad guy -- the one guy
   who might be an obstacle to zeroing everything.  Claim: If it's
   possible to zero this guy then it's possible to zero everything.
   
   Proof of claim: We've discovered two sequences.  One that zeros
   everything but position k, and one that zeros position k but may
   leave some others non-zero.  The last algorithm that zeroed k was
   too focused on k.  There must be another algorithm between the two
   that does just the right amount of work on k, to zero it, and also
   zero everything else.

   Note that this solution does not find this algorithm, it just
   proves that it must exist.
