15-451 Algorithms
D. Sleator

Amortized analysis --- growing and shrinking a table

I'm sure you all know the trick of doubling an array when it needs to
grow.  Then the amortized cost of all the growing operations is still 
O(1).  Why?  Because if the array ends up of size N, the total cost of
all the doublings is 1+2+4+...N, which is at most 2N.  And you needed
the array to be size at least N/2 (or the last doubling would not have
been done).  Thus the cost of all the doublings is at most 4 times the
number of insertions.  The cost of the insertions themselves is 1
per insertion.  Thus we get an amortized bound of 5.

[
This can be proven using a potential, of course.

Let s = number of things in the array, let n be the current size of
the array.  Here's the potential:

   Phi(n,s) = 0 if s<n/2  and  4(s-n/2) otherwise

When a doubling occurs from n to 2n, the cost is 2n.
the potential before is 2n and the potential after is 0.
thus, the amortized cost of the doubling is 0.

The cost of an insertion (increasing s) is 4 (change in potential)
plus 1 (work of the insertion itself).
]

This lecture deals with the situation when the array is allowed to
shrink as well as grow.

A data structure uses a contiguous block of memory, but the size of
the block needed changes over time.  This situation arises when
implementing a hash table, or a growable array, such as in perl, or
using an array to represent a stack.  We'd like to be able to have the
table grow and shrink dynamically, so it does not use too much more
space than absolutely necessary.  But growing or shrinking the table
is expensive -- requiring moving everything in the table around.

The model we'll use is the following:

The external operations offered to the client are:

  initialize()    create a new table with nothing in it
  insert()        add a new object to the table
  delete()        delete the given element from the table

(Of course there will be other operations such as lookup() that are
immaterial for our purposes.)

At any given time the size of the current array will be denoted by n
and the number of things in the table will be denoted by s.

To implement the above operations, we'll need two other primitives to
deal with the array:

  grow()     Change the size of the array from n to 2n
             the cost of this operation is 2n

  shrink()   Change the size of the array from n to n/2
             the cost of this operation is n             

Using these primitives, here's how we implement the interface:

  initialize()    Start with s=0 and n=4

  insert()        If s=n, then grow()
                  now insert the object into the table
                  (cost of insert part is 1)

  delete()        if s=n/4 (and n>4) then shrink()
                  now delete the object from the table
                  (cost of delete part is 1)

Lemma: The amortized cost of an insertion or deletion are
bounded by 5.

Proof:  Let the potential be the following:

       Phi(n,s) = 4|s-n/2|

What is the amortized cost of an insertion?  It's the actual cost plus
the change in potential.  A grow() may or may not happen as a result
of an insertion.  If a grow() occurs, what is the amortized cost of
it?  Before the grow() the potential is 4|n-n/2| = 2n.  After the grow
the potential is 0.  The actual cost of the grow is 2n.  Thus the
amortized cost of the grow is 0.

What about the rest of the insert? 

   actual cost of insert = 1
   change in potential <= 4.

    ====> amortized cost of insert <= 5.

What about delete?  If a shrink() happens, then the potential
decreases by n, and the cost is n, so the amortized cost of shrink()
is 0.  What about the rest of the delete:

   actual cost of delete = 1
   change in potential <= 4.

    ====> amortized cost of delete <= 5.

This completes the proof.  QED.


Theorem: The total cost of a sequence of N insertions and deletions is
at most 5N + 8.

Proof:  The amortized and real costs are related as follows:

   SUM (actual costs) <= SUM(amortized costs)
                          + initial_potential - final_potential

The initial potential is 8.  The final potential is non-negative. 
The sum of the amortized costs are 5.  QED.

Actually, it's easy to get rid of the "+8" part.  All we have to do
is change the potential for n=4 to the following:

               [ 4|s-2|  if  s >= 2
    Phi(4,s) = [
               [ 0           otherwise

Thus, we've zeroed the potential for the case when the initial array
of size 4 is less than half full.  The proof still goes through,
because we never shrink an array of size 4, and this part of the
potential is not important.  This new potential has an initial value
of 0, completing the proof.
