\documentclass[12pt]{exam}
\usepackage{amsmath}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}

\newcommand\Cnought{C$_0$}
\newcommand\modulo{\ \texttt{\%}\ }
\newcommand\lshift{\ \texttt{<<}\ }
\newcommand\rshift{\ \texttt{>>}\ }
\newcommand\cgeq{\ \texttt{>=}\ }


\pagestyle{head}

\headrule \header{\textbf{15-122 Assignment 2}}{}{\textbf{Page
\thepage\ of \numpages}}

\pointsinmargin \printanswers

\setlength\answerlinelength{2in} \setlength\answerskip{0.3in}

\begin{document}
\addpoints
\begin{center}
\textbf{\large{15-122 : Principles of Imperative Computation
 \\ \vspace{0.2in} Fall 2011
\\  \vspace{0.2in} Assignment 2
}}

 \vspace{0.2in}
 (\large{Theory Part})

 \vspace{0.2in}

 \large{Due: Thursday, September 22, 2011 in class}
\end{center}

\vspace{0.5in}

\hbox to \textwidth{Name:\enspace\hrulefill}


\vspace{0.2in}

\hbox to \textwidth{Andrew ID:\enspace\hrulefill}

\vspace{0.2in}

\hbox to \textwidth{Recitation:\enspace\hrulefill}



% End title box
\vspace{0.5in}

\noindent The written portion of this week's homework will give you some practice
working with searching algorithms and test
your understanding of contracts.
You can either type up your solutions or write them
\textit{neatly} by hand, and you should submit your work in class on the
due date just before lecture or recitation begins. Please remember to \textit{staple}
your written homework before submission.
\vspace{0.2in}

\begin{center}
\gradetable[v][questions]
\end{center}


\newpage
\begin{questions}
\question{\textbf{\Cnought{} Operators.}}
Let $x$ be an \texttt{int} in the \Cnought{} language.  Express the
following operations in \Cnought{} using only one statement each.
(Do not use an \texttt{if} statement here.)
You should think about using some of the bitwise operators:
(\texttt{\&}, \texttt{|}, \texttt{\^}, \texttt{\~}, \texttt{<<}, \texttt{>>}).
\begin{parts}

\part[2] Rotate $x$ left one bit. (The leftmost bit reenters $x$ in
      the rightmost position.) Store the result back in $x$.

\begin{solution}
\vspace{1in}
\end{solution}

\part[2] Rotate $x$ right one bit. (The rightmost bit reenters $x$ in
      the leftmost position.) Store the result back in $x$.

\begin{solution}
\vspace{1in}
\end{solution}

\end{parts}






\question{\textbf{Reasoning with Invariants.}}
Consider the following implementation of the linear search algorithm that
finds the last occurrence of \texttt{x} in array \texttt{A}:
\begin{verbatim}
  int find(int x, int[] A, int n)
  //@requires 0 <= n && n <= \length(A);
  //@requires is_sorted(A, 0, n);
  {
    int i = n-1;
    while (i >= 0 && A[i] >= x)
    {
      if (A[i] == x) return i;
      i = i - 1;
    }
    return -1;
  }
\end{verbatim}
Note that the function \verb+is_sorted+ is slightly different from the one we
have been using in lecture---it takes a lower bound as well as an upper bound
for the range of the array that we care about.

\newpage
\begin{parts}
\part[2] Add loop invariants to the code and show that the they
      hold for this loop.   Be sure that the loop invariants precisely describe
      the computation in the loop.
\begin{solution}
\vspace{1in}
\end{solution}

 \part[2]Add one or more \texttt{ensures} clause(s) to describe the intended postcondition in a precise manner.
\begin{solution}
\vspace{1in}
\end{solution}

\part[4]Show that the loop invariant is {\it strong enough} by using the loop invariant to prove that the postconditions hold at the end of the function (both if it ends by the return statement in the loop or the return statement after the
    loop exits).
\begin{solution}
\vspace{3.9in}
\end{solution}

\end{parts}




\question{\textbf{Binary Search.}}
\begin{parts}
\part[3]
An array can have duplicate values. A programmer wrote the following
variant of binary search to find the first occurrence of $x$ in a sorted
array \texttt{A} of $n$ integers so that the asymptotic complexity is still
$O(\log n)$:

\begin{verbatim}
int binsearch_smallest(int x, int[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (\result == -1 && !is_in(x, A, n))
        || (0 <= \result && \result < n && A[\result] == x
            && (\result == 0 || A[\result-1] < x));
  @*/
{
  int lower = 0;
  int upper = n;
  while (lower < upper)
  //@loop_invariant 0 <= lower && lower <= upper && upper <= n;
  //@loop_invariant lower == 0 || A[lower-1] < x;
  //@loop_invariant upper == n || A[upper] >= x;
  {
      int mid = lower + (upper-lower)/2;
      if (A[lower] == x) return lower;
      if (A[mid] < x) lower = mid+1;
      else upper = mid;
  }
  //@assert lower == upper;
  return -1;
}
\end{verbatim}

\noindent There is a bug in this implementation. Describe the bug and fix the code
(and the annotations if necessary) so that it works correctly.

\begin{solution}
\vspace{3in}
\end{solution}

\newpage

\part[3] Consider the following variation of binary search algorithm. Instead of checking the middle
element of the sorted array $A[]$, check the element at position $n/3$. Then proceed in the same way as
in binary search. If you are looking for $x$ then

    \begin{itemize}
\item if $x = A[n/3]$ you have found it.
\item if $x < A[n/3]$  you search the first third of the array, namely at indexes  $< n/3$.
\item if $x > A[n/3]$ you search the rest two thirds of the array at indexes $> n/3$.
    \end{itemize}

Is this algorithm is faster or slower than binary search given in class? Explain your answer.
\begin{solution}
\vspace{3in}
\end{solution}




\end{parts}


\newpage
\question{\textbf{Runtime Complexity.}} Consider the following function that sorts the integers in an array. (You may assume the code is correct so most annotations are not shown.)

\begin{verbatim}
  int sort(int[] A, int n)
  //@requires 0 <= n && n <= \length(A);
  {
    int i = 1;
    while (i < n)
    {
      int j = i;
      while (j != 0 && A[j-1] > A[j])
      {
        swap(A, j-1, j);    // function that swaps A[j-1] with A[j]
        j = j - 1;
      }
      i = i + 1;
    }
  }
\end{verbatim}

\begin{parts}
\part[2] Let $T(n)$ be the number of comparisons needed to sort an array $n$ elements. Using big-$O$ notation describe the worst-case runtime complexity of \texttt{sort()}.
\begin{solution}

\quad \quad \quad \quad $T(n) = O( $
\vspace{0.1in}
\end{solution}



\part[2] Using your answer from the previous part,
prove that $T(n) = O(f(n))$ using the formal definition of big $O$.
That is, find $c > 0$ and $n_0 \geq 0$ such that for every $n \geq n_0$, $T(n) \leq
cf(n)$.
\begin{solution}
\vspace{2.9in}
\end{solution}

\end{parts}


\newpage

\question[3]{\textbf{More on Contracts.}}
This question is designed to test your knowledge of contracts,
how they are checked dynamically, and how they can be used to reason
about the correctness of your program.  Your job is to identify the locations in a \Cnought{} function and a
main function that calls it where contracts are checked and where you can assume
that contracts must be true.  Consider the {\tt mult} function and a {\tt main} function that calls it:

\begin{verbatim}
int mult(int x, int y)
//@requires x >= 0 && y >= 0;
//@ensures \result == x*y;
{
  int k = x;
  int n = y;
  int res = 0;
  while (n != 0)
  //@loop_invariant x * y == k * n + res;
  {
     if ((k & 1) == 1) res = res + n;
     k = k >> 1;
     n = n << 1;
  }
  return res;
}

int main()
{
  int a;
  a = mult(3,4);
  return a;
}

\end{verbatim}
    \newpage


When you compile your \Cnought{} program with the {\tt -d} flag, it
	adds runtime tests to your program which are checked when it is executed.
	Based on the contracts for the {\tt mult} function above, write {\tt CHECK
	B} at any point in the copy of the function below where a boolean expression
	{\tt B} is checked by a contract in the {\tt main} and {\tt mult} functions
	given that they are compiled with the {\tt -d} flag. Note: not all blank
	lines below should be filled in.

\begin{verbatim}
int mult(int x, int y) {

  _________________________
  int k = x; int n = y;
  int res = 0;

  ________________________
  while (n != 0) {

      _________________________
      if ((k & 1) == 1) res = res + n;
      k = k >> 1;
      n = n << 1;

      _________________________
   }

  _________________________
  return res;
}

int main() {
  int a;

  _____________
  a = mult(3,4);

  _____________
  return a;
}
\end{verbatim}

\end{questions}
\end{document}

